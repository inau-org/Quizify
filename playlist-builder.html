<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Spotify Quiz – Playlist Builder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
          crossorigin="anonymous" />

    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        textarea#jsonOutput {
            font-family: monospace;
        }

        .track-card .btn-quiz {
            min-width: 120px;
        }

        .value-pill {
            padding: 0.1rem 0.5rem;
            border-radius: 999px;
            background-color: rgba(0,0,0,0.03);
        }
    </style>
</head>

<body class="bg-light">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark mb-4">
        <div class="container">
            <a class="navbar-brand" href="index.html">Quizify</a>

            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#mainNav"
                    aria-controls="mainNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="mainNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a id="navHome" class="nav-link" href="index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a id="navBuilder" class="nav-link" href="playlist-builder.html">Builder</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container py-4">
        <!-- Header / Login -->
        <div class="card shadow-sm mb-4">
            <div class="card-body d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3">
                <div>
                    <h1 class="h3 mb-1">Spotify Quiz – Playlist Builder</h1>
                    <p id="loginStatus" class="mb-0 text-muted">Checking login status…</p>
                    <div id="errorBox" class="text-danger small mt-1"></div>
                </div>
                <div class="text-md-end">
                    <button id="loginBtn" class="btn btn-success">
                        Log in with Spotify
                    </button>
                    <div id="deviceStatus" class="small mt-2 text-muted"></div>
                    <button id="openSpotifyBtn" class="btn btn-outline-secondary btn-sm mt-2 d-none">
                        Open Spotify
                    </button>
                </div>
            </div>
        </div>

        <!-- Playlist Selection -->
        <div class="card shadow-sm mb-4">
            <div class="card-body">
                <h2 class="h5 mb-3">Select Playlist</h2>
                <div class="row g-3 align-items-end">
                    <div class="col-12 col-md-8">
                        <label for="playlistSelect" class="form-label">Current Playlist</label>
                        <select id="playlistSelect" class="form-select">
                            <option value="">(No playlists available)</option>
                        </select>
                        <div class="form-text">
                            Select a playlist to edit, or create a new one.
                        </div>
                    </div>
                    <div class="col-12 col-md-4 d-flex gap-2 justify-content-md-end">
                        <button id="newPlaylistBtn" class="btn btn-outline-primary w-100 w-md-auto mt-3 mt-md-0">
                            <i class="bi bi-plus-lg"></i> New Playlist
                        </button>
                    </div>
                </div>
                <div id="playlistStatus" class="mt-2 small"></div>
            </div>
        </div>

        <!-- Add track -->
        <div class="card shadow-sm mb-4">
            <div class="card-body">
                <h2 class="h5 mb-3">Add track by URI or URL</h2>
                <div class="row g-3 align-items-end">
                    <div class="col-12 col-md-8">
                        <label for="spotifyInput" class="form-label">Spotify track URI or URL</label>
                        <input type="text"
                               id="spotifyInput"
                               class="form-control"
                               placeholder="spotify:track:ID or https://open.spotify.com/track/ID?si=..." />
                        <div class="form-text">
                            Paste a track URI or URL. We'll fetch metadata and set slider limits automatically.
                        </div>
                    </div>
                    <div class="col-12 col-md-4 d-flex justify-content-md-end">
                        <button id="addTrackBtn" class="btn btn-primary w-100 w-md-auto mt-3 mt-md-0">
                            Add track
                        </button>
                    </div>
                </div>
                <div id="builderError" class="text-danger small mt-2"></div>
            </div>
        </div>

        <!-- Tracks list -->
        <div class="card shadow-sm mb-4">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h2 class="h5 mb-0">Tracks in playlist</h2>
                    <button id="saveToStorageBtn" class="btn btn-success" disabled>
                        Save Changes
                    </button>
                </div>
                <div id="tracksContainer" class="d-grid gap-3">
                    <div id="noTracksHint" class="text-muted small">
                        No tracks yet. Add one using the field above.
                    </div>
                </div>
                <div id="saveStatus" class="mt-2 small"></div>
            </div>
        </div>

        <!-- Export / Import -->
        <div class="card shadow-sm">
            <div class="card-body">
                <h2 class="h5 mb-3">Export / Import JSON</h2>
                <div class="mb-3 d-flex gap-2 flex-wrap">
                    <button id="exportJsonBtn" class="btn btn-success">
                        Export JSON
                    </button>
                    <button id="importJsonBtn" class="btn btn-outline-primary">
                        Import from JSON
                    </button>
                </div>
                <label for="jsonOutput" class="form-label">tracks.json content</label>
                <textarea id="jsonOutput"
                          class="form-control"
                          rows="10"
                          spellcheck="false"
                          placeholder='Paste JSON here to import, e.g.:
[
  {
    "id": "clip1",
    "name": "Song #1",
    "uri": "spotify:track:...",
    "startMs": 0,
    "durationMs": 2000
  }
]'></textarea>
                <div class="form-text">
                    Use <strong>Export JSON</strong> to generate JSON from your current tracks, or paste JSON and click <strong>Import from JSON</strong> to load tracks into the builder.
                </div>
                <div id="importStatus" class="mt-2 small"></div>
            </div>
        </div>
    </div>

    <!-- New Playlist Modal -->
    <div class="modal fade" id="newPlaylistModal" tabindex="-1" aria-labelledby="newPlaylistModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="newPlaylistModalLabel">Create New Playlist</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="newPlaylistNameInput" class="form-label">Playlist Name</label>
                        <input type="text"
                               class="form-control"
                               id="newPlaylistNameInput"
                               placeholder="e.g., my-awesome-playlist"
                               autocomplete="off" />
                        <div class="form-text">
                            This will be saved as <code>tracklist:&lt;name&gt;</code> in localStorage.
                        </div>
                    </div>
                    <div id="newPlaylistError" class="text-danger small"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="createPlaylistBtn">Create Playlist</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =====================
        //   CONFIG
        // =====================

        const CLIENT_ID = "0bbfd2ff3da1471dae3b2e35b0714720";
        const REDIRECT_URI = "https://inau-org.github.io/Quizify/playlist-builder.html";

        const SCOPES = [
            "user-modify-playback-state",
            "user-read-playback-state"
        ];

        // =====================
        //   STATE
        // =====================

        let accessToken = null;
        const builderTracks = []; // { index, uri, trackId, durationMs, startMs, clipMs, meta }
        let currentPlaylistName = null; // Currently selected playlist

        // Storage prefix
        const STORAGE_PREFIX = "tracklist:";

        // =====================
        //   PKCE HELPERS
        // =====================

        function generateRandomString(length = 64) {
            const possible =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
            let text = "";
            const array = new Uint8Array(length);
            window.crypto.getRandomValues(array);
            for (let i = 0; i < length; i++) {
                text += possible[array[i] % possible.length];
            }
            return text;
        }

        function base64UrlEncode(arrayBuffer) {
            const bytes = new Uint8Array(arrayBuffer);
            let binary = "";
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            const base64 = window.btoa(binary);
            return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
        }

        async function createCodeChallenge(codeVerifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(codeVerifier);
            const digest = await window.crypto.subtle.digest("SHA-256", data);
            return base64UrlEncode(digest);
        }

        // =====================
        //   AUTH FLOW
        // =====================

        function updateAuthStatus(message) {
            const statusEl = document.getElementById("loginStatus");
            const loginBtn = document.getElementById("loginBtn");

            if (!statusEl || !loginBtn) return;

            if (accessToken) {
                statusEl.textContent = message || "Logged in with Spotify";
                loginBtn.textContent = "Already logged in";
                loginBtn.classList.remove("btn-success");
                loginBtn.classList.add("btn-secondary");
                loginBtn.disabled = true;
            } else {
                statusEl.textContent = message || "Not logged in";
                loginBtn.textContent = "Log in with Spotify";
                loginBtn.classList.remove("btn-secondary");
                loginBtn.classList.add("btn-success");
                loginBtn.disabled = false;
            }
        }

        function showError(msg) {
            console.error(msg);
            const box = document.getElementById("errorBox");
            if (box) box.textContent = msg;
        }

        function showBuilderError(msg) {
            const box = document.getElementById("builderError");
            if (box) box.textContent = msg || "";
        }

        function showImportStatus(msg, isError = false) {
            const box = document.getElementById("importStatus");
            if (box) {
                box.textContent = msg || "";
                box.className = isError ? "mt-2 small text-danger" : "mt-2 small text-success";
            }
        }

        function showSaveStatus(msg, isError = false) {
            const box = document.getElementById("saveStatus");
            if (box) {
                box.textContent = msg || "";
                box.className = isError ? "mt-2 small text-danger" : "mt-2 small text-success";
            }
        }

        function showPlaylistStatus(msg, isError = false) {
            const box = document.getElementById("playlistStatus");
            if (box) {
                box.textContent = msg || "";
                box.className = isError ? "mt-2 small text-danger" : "mt-2 small text-success";
            }
        }

        function showNewPlaylistError(msg) {
            const box = document.getElementById("newPlaylistError");
            if (box) box.textContent = msg || "";
        }

        function storeToken(token, expiresInSeconds) {
            accessToken = token;
            const expiryTime = Date.now() + expiresInSeconds * 1000;
            localStorage.setItem("spotify_builder_access_token", token);
            localStorage.setItem("spotify_builder_token_expiry", String(expiryTime));
            updateAuthStatus("Logged in with Spotify");
            checkDevices();
        }

        function getStoredToken() {
            const token = localStorage.getItem("spotify_builder_access_token");
            const expiry = localStorage.getItem("spotify_builder_token_expiry");
            if (!token || !expiry) return null;
            if (Date.now() > Number(expiry)) {
                localStorage.removeItem("spotify_builder_access_token");
                localStorage.removeItem("spotify_builder_token_expiry");
                return null;
            }
            return token;
        }

        async function startAuth() {
            try {
                const codeVerifier = generateRandomString(64);
                const codeChallenge = await createCodeChallenge(codeVerifier);
                const state = generateRandomString(16);

                sessionStorage.setItem("spotify_builder_pkce_code_verifier", codeVerifier);
                sessionStorage.setItem("spotify_builder_pkce_state", state);

                const params = new URLSearchParams({
                    client_id: CLIENT_ID,
                    response_type: "code",
                    redirect_uri: REDIRECT_URI,
                    scope: SCOPES.join(" "),
                    code_challenge_method: "S256",
                    code_challenge: codeChallenge,
                    state
                });

                window.location.href =
                    "https://accounts.spotify.com/authorize?" + params.toString();

            } catch (e) {
                showError("Could not start login flow: " + e.message);
            }
        }

        async function handleRedirectCallback() {
            const url = new URL(window.location.href);
            const code = url.searchParams.get("code");
            const returnedState = url.searchParams.get("state");
            const error = url.searchParams.get("error");

            if (error) {
                showError("Spotify login error: " + error);
                url.searchParams.delete("error");
                window.history.replaceState({}, document.title, url.pathname + url.search);
                return;
            }

            if (!code) return;

            const storedState = sessionStorage.getItem("spotify_builder_pkce_state");
            if (storedState && returnedState && storedState !== returnedState) {
                showError("State mismatch – login aborted.");
                return;
            }

            const codeVerifier = sessionStorage.getItem("spotify_builder_pkce_code_verifier");
            if (!codeVerifier) {
                showError("Missing code_verifier – please log in again.");
                return;
            }

            url.searchParams.delete("code");
            url.searchParams.delete("state");
            window.history.replaceState({}, document.title, url.pathname + url.search);

            try {
                const body = new URLSearchParams({
                    client_id: CLIENT_ID,
                    grant_type: "authorization_code",
                    code,
                    redirect_uri: REDIRECT_URI,
                    code_verifier: codeVerifier
                });

                const res = await fetch("https://accounts.spotify.com/api/token", {
                    method: "POST",
                    headers: { "Content-Type": "application/x-www-form-urlencoded" },
                    body: body.toString()
                });

                if (!res.ok) {
                    const txt = await res.text();
                    throw new Error("Token error " + res.status + ": " + txt);
                }

                const data = await res.json();
                if (!data.access_token) {
                    throw new Error("No access_token in response.");
                }

                storeToken(data.access_token, data.expires_in || 3600);

            } catch (e) {
                showError("Could not exchange code for token: " + e.message);
            } finally {
                sessionStorage.removeItem("spotify_builder_pkce_code_verifier");
                sessionStorage.removeItem("spotify_builder_pkce_state");
            }
        }

        // =====================
        //   SPOTIFY API + DEVICES
        // =====================

        async function spotifyFetch(method, endpoint, body) {
            if (!accessToken) throw new Error("No access token");
            const res = await fetch("https://api.spotify.com/v1" + endpoint, {
                method,
                headers: {
                    "Authorization": "Bearer " + accessToken,
                    "Content-Type": "application/json"
                },
                body: body ? JSON.stringify(body) : undefined
            });

            if (res.status === 204) return null;

            if (!res.ok) {
                const txt = await res.text();
                throw new Error("Spotify API error " + res.status + ": " + txt);
            }

            return await res.json();
        }

        function updateDeviceUi(hasActiveDevice, devices) {
            const statusEl = document.getElementById("deviceStatus");
            const openBtn = document.getElementById("openSpotifyBtn");
            if (!statusEl || !openBtn) return;

            if (!accessToken) {
                statusEl.textContent = "";
                openBtn.classList.add("d-none");
                return;
            }

            if (hasActiveDevice) {
                const activeNames = (devices || [])
                    .filter(d => d.is_active)
                    .map(d => d.name)
                    .join(", ");
                statusEl.textContent = activeNames
                    ? `Active device: ${activeNames}`
                    : "Active playback device detected.";
                openBtn.classList.add("d-none");
            } else {
                statusEl.textContent =
                    "No active Spotify device found. Open Spotify and start any track once, then try again.";
                openBtn.classList.remove("d-none");
            }
        }

        async function checkDevices() {
            if (!accessToken) {
                updateDeviceUi(false, []);
                return;
            }
            try {
                const data = await spotifyFetch("GET", "/me/player/devices");
                const devices = data.devices || [];
                const hasActive = devices.some(d => d.is_active);
                updateDeviceUi(hasActive, devices);
            } catch (e) {
                console.error("Error fetching devices:", e);
            }
        }

        // =====================
        //   PLAYLIST MANAGEMENT
        // =====================

        function getAllPlaylistNames() {
            const names = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(STORAGE_PREFIX)) {
                    names.push(key.slice(STORAGE_PREFIX.length));
                }
            }
            return names;
        }

        function loadPlaylistFromStorage(name) {
            const key = STORAGE_PREFIX + name;
            const raw = localStorage.getItem(key);
            if (!raw) return null;

            try {
                const data = JSON.parse(raw);
                return Array.isArray(data) ? data : null;
            } catch (e) {
                console.error("Failed to parse playlist:", e);
                return null;
            }
        }

        function savePlaylistToStorage(name, tracks) {
            const key = STORAGE_PREFIX + name;
            try {
                localStorage.setItem(key, JSON.stringify(tracks));
                return true;
            } catch (e) {
                console.error("Failed to save playlist:", e);
                return false;
            }
        }

        function populatePlaylistDropdown() {
            const selectEl = document.getElementById("playlistSelect");
            const names = getAllPlaylistNames();

            selectEl.innerHTML = "";

            if (names.length === 0) {
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "(No playlists available)";
                selectEl.appendChild(opt);
                updateSaveButton();
                return;
            }

            // Add placeholder
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "-- Select a playlist --";
            selectEl.appendChild(placeholder);

            // Add all playlists
            names.forEach(name => {
                const opt = document.createElement("option");
                opt.value = name;
                opt.textContent = name;
                selectEl.appendChild(opt);
            });

            // Restore previous selection if available
            if (currentPlaylistName && names.includes(currentPlaylistName)) {
                selectEl.value = currentPlaylistName;
            }

            updateSaveButton();
        }

        function loadSelectedPlaylist() {
            const selectEl = document.getElementById("playlistSelect");
            const selectedName = selectEl.value;

            if (!selectedName) {
                currentPlaylistName = null;
                builderTracks.length = 0;
                renderTracks();
                showPlaylistStatus("No playlist selected.", true);
                updateSaveButton();
                return;
            }

            const tracks = loadPlaylistFromStorage(selectedName);
            if (!tracks) {
                showPlaylistStatus(`Could not load playlist "${selectedName}".`, true);
                return;
            }

            currentPlaylistName = selectedName;
            builderTracks.length = 0;

            // Convert stored tracks to builder format
            tracks.forEach((t, idx) => {
                builderTracks.push({
                    index: idx + 1,
                    uri: t.uri,
                    trackId: extractTrackId(t.uri),
                    durationMs: 0, // Will be fetched if needed
                    startMs: t.startMs || 0,
                    clipMs: t.durationMs || 2000,
                    meta: {
                        name: t.name || `Song #${idx + 1}`,
                        artists: []
                    }
                });
            });

            renderTracks();
            showPlaylistStatus(`Loaded "${selectedName}" with ${tracks.length} track(s).`, false);
            updateSaveButton();
        }

        function updateSaveButton() {
            const saveBtn = document.getElementById("saveToStorageBtn");
            if (currentPlaylistName) {
                saveBtn.disabled = false;
                saveBtn.textContent = `Save to "${currentPlaylistName}"`;
            } else {
                saveBtn.disabled = true;
                saveBtn.textContent = "Save Changes";
            }
        }

        function createNewPlaylist() {
            const nameInput = document.getElementById("newPlaylistNameInput");
            const playlistName = nameInput.value.trim();

            showNewPlaylistError("");

            if (!playlistName) {
                showNewPlaylistError("Please enter a playlist name.");
                return;
            }

            // Check if playlist already exists
            const existingNames = getAllPlaylistNames();
            if (existingNames.includes(playlistName)) {
                showNewPlaylistError(`Playlist "${playlistName}" already exists.`);
                return;
            }

            // Create empty playlist
            if (!savePlaylistToStorage(playlistName, [])) {
                showNewPlaylistError("Failed to create playlist.");
                return;
            }

            // Update UI
            populatePlaylistDropdown();
            const selectEl = document.getElementById("playlistSelect");
            selectEl.value = playlistName;
            currentPlaylistName = playlistName;

            // Clear tracks
            builderTracks.length = 0;
            renderTracks();

            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById("newPlaylistModal"));
            modal.hide();

            // Clear input
            nameInput.value = "";

            showPlaylistStatus(`Created new playlist "${playlistName}".`, false);
            updateSaveButton();
        }

        // =====================
        //   HELPER: URI / ID
        // =====================

        function extractTrackId(input) {
            if (!input) return null;
            input = input.trim();

            if (input.startsWith("spotify:track:")) {
                return input.split(":")[2] || null;
            }

            const openIdx = input.indexOf("open.spotify.com/track/");
            if (openIdx !== -1) {
                const after = input.slice(openIdx + "open.spotify.com/track/".length);
                const qIdx = after.indexOf("?");
                const id = qIdx === -1 ? after : after.slice(0, qIdx);
                return id || null;
            }

            if (input.length === 22 && !input.includes(" ")) {
                return input;
            }

            return null;
        }

        function buildUriFromInput(input) {
            const id = extractTrackId(input);
            if (!id) return null;
            return {
                uri: "spotify:track:" + id,
                id
            };
        }

        function msToSecondsLabel(ms) {
            const s = ms / 1000;
            return s.toFixed(2) + " s";
        }

        // =====================
        //   RENDER + ROW LOGIC
        // =====================

        function renderTracks() {
            const container = document.getElementById("tracksContainer");
            if (!container) {
                return;
            }

            const noTracksHint = document.getElementById("noTracksHint");
            container.innerHTML = "";

            if (builderTracks.length === 0) {
                if (noTracksHint) {
                    noTracksHint.classList.remove("d-none");
                    container.appendChild(noTracksHint);
                } else {
                    container.textContent = "No tracks yet. Add one using the field above.";
                }
                return;
            }

            if (noTracksHint) {
                noTracksHint.classList.add("d-none");
            }

            builderTracks.forEach((t, idx) => {
                const card = document.createElement("div");
                card.className = "card track-card";

                const body = document.createElement("div");
                body.className = "card-body";

                const headerRow = document.createElement("div");
                headerRow.className = "d-flex justify-content-between align-items-center mb-2";

                const leftHeader = document.createElement("div");
                const songLabel = document.createElement("div");
                songLabel.className = "fw-semibold";
                songLabel.textContent = `Song #${t.index}`;

                const metaLabel = document.createElement("div");
                metaLabel.className = "small text-muted";
                const artist = (t.meta.artists || []).join(", ");
                metaLabel.textContent = t.durationMs > 0
                    ? `${t.meta.name} – ${artist} (${msToSecondsLabel(t.durationMs)} total)`
                    : `${t.meta.name} – ${artist}`;

                leftHeader.appendChild(songLabel);
                leftHeader.appendChild(metaLabel);

                const previewBtn = document.createElement("button");
                previewBtn.className = "btn btn-outline-primary btn-sm btn-quiz";
                previewBtn.textContent = "Preview";
                previewBtn.onclick = () => previewClip(t);

                headerRow.appendChild(leftHeader);
                headerRow.appendChild(previewBtn);

                // Sliders
                const sliderBlock = document.createElement("div");
                sliderBlock.className = "mt-2";

                // Start slider
                const startGroup = document.createElement("div");
                startGroup.className = "mb-2";

                const startLabelRow = document.createElement("div");
                startLabelRow.className = "d-flex justify-content-between align-items-center mb-1";

                const startLabel = document.createElement("span");
                startLabel.textContent = "Start offset";

                const startVal = document.createElement("span");
                startVal.className = "small value-pill";
                startVal.textContent = `${t.startMs} ms (${msToSecondsLabel(t.startMs)})`;

                startLabelRow.appendChild(startLabel);
                startLabelRow.appendChild(startVal);

                const startRange = document.createElement("input");
                startRange.type = "range";
                startRange.min = "0";
                startRange.max = String(Math.max(0, t.durationMs > 0 ? t.durationMs - 500 : 300000));
                startRange.value = String(t.startMs);
                startRange.className = "form-range";
                startRange.step = "10";

                const startLimits = document.createElement("div");
                startLimits.className = "small text-muted d-flex justify-content-between";
                startLimits.innerHTML = `<span>Min: 0 ms</span><span>Max: ${t.durationMs > 0 ? t.durationMs : 300000} ms</span>`;

                startGroup.appendChild(startLabelRow);
                startGroup.appendChild(startRange);
                startGroup.appendChild(startLimits);

                // Duration slider
                const durGroup = document.createElement("div");

                const durLabelRow = document.createElement("div");
                durLabelRow.className = "d-flex justify-content-between align-items-center mb-1";

                const durLabel = document.createElement("span");
                durLabel.textContent = "Clip duration";

                const durVal = document.createElement("span");
                durVal.className = "small value-pill";
                durVal.textContent = `${t.clipMs} ms (${msToSecondsLabel(t.clipMs)})`;

                durLabelRow.appendChild(durLabel);
                durLabelRow.appendChild(durVal);

                const durRange = document.createElement("input");
                durRange.type = "range";
                durRange.min = "200";
                durRange.max = String(t.durationMs > 0 ? t.durationMs : 300000);
                durRange.value = String(t.clipMs);
                durRange.className = "form-range";
                durRange.step = "10";

                const durLimits = document.createElement("div");
                durLimits.className = "small text-muted d-flex justify-content-between";
                durLimits.innerHTML = `<span>Min: 200 ms</span><span>Max: ${t.durationMs > 0 ? t.durationMs : 300000} ms</span>`;

                durGroup.appendChild(durLabelRow);
                durGroup.appendChild(durRange);
                durGroup.appendChild(durLimits);

                sliderBlock.appendChild(startGroup);
                sliderBlock.appendChild(durGroup);

                // Wire slider logic
                startRange.addEventListener("input", () => {
                    const newStart = Number(startRange.value);
                    t.startMs = Math.max(0, newStart);
                    const maxClip = Math.max(200, (t.durationMs > 0 ? t.durationMs : 300000) - t.startMs);
                    if (t.clipMs > maxClip) {
                        t.clipMs = maxClip;
                        durRange.value = String(t.clipMs);
                    }
                    startVal.textContent = `${t.startMs} ms (${msToSecondsLabel(t.startMs)})`;
                    durVal.textContent = `${t.clipMs} ms (${msToSecondsLabel(t.clipMs)})`;
                });

                durRange.addEventListener("input", () => {
                    let newClip = Number(durRange.value);
                    const maxClip = Math.max(200, (t.durationMs > 0 ? t.durationMs : 300000) - t.startMs);
                    if (newClip > maxClip) {
                        newClip = maxClip;
                        durRange.value = String(newClip);
                    }
                    t.clipMs = Math.max(200, newClip);
                    durVal.textContent = `${t.clipMs} ms (${msToSecondsLabel(t.clipMs)})`;
                });

                body.appendChild(headerRow);
                body.appendChild(sliderBlock);
                card.appendChild(body);
                container.appendChild(card);
            });
        }

        // =====================
        //   PREVIEW
        // =====================

        async function previewClip(track) {
            if (!accessToken) {
                alert("Please log in with Spotify first.");
                return;
            }

            try {
                await spotifyFetch("PUT", "/me/player/play", {
                    uris: [track.uri],
                    position_ms: track.startMs
                });

                const dur = track.clipMs || 2000;

                setTimeout(() => {
                    spotifyFetch("PUT", "/me/player/pause").catch(err =>
                        console.error("Pause error:", err)
                    );
                }, dur);

            } catch (e) {
                console.error("Preview error:", e);
                const msg = String(e.message || "");
                if (msg.includes("NO_ACTIVE_DEVICE")) {
                    checkDevices();
                    alert(
                        "No active Spotify device found. Open Spotify, start any track once, then try again."
                    );
                } else {
                    alert(
                        "Could not play preview. Check you have an active Spotify device and (usually) a Premium account."
                    );
                }
            }
        }

        // =====================
        //   ADD TRACK FLOW
        // =====================

        async function addTrackFromInput() {
            showBuilderError("");

            if (!accessToken) {
                showBuilderError("Please log in with Spotify first.");
                return;
            }

            if (!currentPlaylistName) {
                showBuilderError("Please select or create a playlist first.");
                return;
            }

            const spotifyInput = document.getElementById("spotifyInput");
            const rawInput = spotifyInput.value.trim();
            if (!rawInput) {
                showBuilderError("Please enter a Spotify track URI or URL.");
                return;
            }

            const parsed = buildUriFromInput(rawInput);
            if (!parsed) {
                showBuilderError("Could not extract a valid track ID from the input.");
                return;
            }

            try {
                const data = await spotifyFetch("GET", "/tracks/" + parsed.id);
                const durationMs = data.duration_ms || 0;
                if (!durationMs) {
                    throw new Error("Track has no duration_ms from API.");
                }

                const index = builderTracks.length + 1;
                const defaultClip = Math.min(2000, durationMs);

                const track = {
                    index,
                    uri: parsed.uri,
                    trackId: parsed.id,
                    durationMs,
                    startMs: 0,
                    clipMs: defaultClip,
                    meta: {
                        name: data.name || "Unknown title",
                        artists: (data.artists || []).map(a => a.name)
                    }
                };

                builderTracks.push(track);
                spotifyInput.value = "";
                renderTracks();

            } catch (e) {
                console.error("Add track error:", e);
                showBuilderError("Could not fetch track metadata: " + e.message);
            }
        }

        // =====================
        //   SAVE TO LOCALSTORAGE
        // =====================

        function saveToLocalStorage() {
            showSaveStatus("");

            if (!currentPlaylistName) {
                showSaveStatus("Please select a playlist first.", true);
                return;
            }

            if (builderTracks.length === 0) {
                showSaveStatus("No tracks to save. Add some tracks first.", true);
                return;
            }

            try {
                const tracksToSave = builderTracks.map((t, idx) => ({
                    id: "clip" + (idx + 1),
                    name: "Song #" + (idx + 1),
                    uri: t.uri,
                    startMs: t.startMs,
                    durationMs: t.clipMs
                }));

                if (!savePlaylistToStorage(currentPlaylistName, tracksToSave)) {
                    throw new Error("Failed to save to localStorage");
                }

                showSaveStatus(
                    `Successfully saved ${builderTracks.length} track(s) to "${currentPlaylistName}".`,
                    false
                );

            } catch (e) {
                console.error("Save error:", e);
                showSaveStatus("Failed to save to localStorage: " + e.message, true);
            }
        }

        // =====================
        //   EXPORT / IMPORT
        // =====================

        function exportJson() {
            const jsonOutput = document.getElementById("jsonOutput");

            if (builderTracks.length === 0) {
                jsonOutput.value = "[]";
                return;
            }

            const arr = builderTracks.map((t, idx) => ({
                id: "clip" + (idx + 1),
                name: "Song #" + (idx + 1),
                uri: t.uri,
                startMs: t.startMs,
                durationMs: t.clipMs
            }));

            const json = JSON.stringify(arr, null, 2);
            jsonOutput.value = json;
        }

        async function importJson() {
            showImportStatus("");

            if (!accessToken) {
                showImportStatus("Please log in with Spotify first.", true);
                return;
            }

            if (!currentPlaylistName) {
                showImportStatus("Please select or create a playlist first.", true);
                return;
            }

            const jsonOutput = document.getElementById("jsonOutput");
            const jsonText = jsonOutput.value.trim();

            if (!jsonText) {
                showImportStatus("Please paste JSON content in the textarea above.", true);
                return;
            }

            let importedTracks;
            try {
                importedTracks = JSON.parse(jsonText);
            } catch (e) {
                showImportStatus("Invalid JSON format: " + e.message, true);
                return;
            }

            if (!Array.isArray(importedTracks)) {
                showImportStatus("JSON must be an array of track objects.", true);
                return;
            }

            if (importedTracks.length === 0) {
                showImportStatus("JSON array is empty.", true);
                return;
            }

            // Clear current tracks
            builderTracks.length = 0;

            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < importedTracks.length; i++) {
                const jsonTrack = importedTracks[i];

                if (!jsonTrack.uri) {
                    console.warn(`Track ${i + 1}: Missing 'uri' field, skipping.`);
                    errorCount++;
                    continue;
                }

                const parsed = buildUriFromInput(jsonTrack.uri);
                if (!parsed) {
                    console.warn(`Track ${i + 1}: Invalid URI '${jsonTrack.uri}', skipping.`);
                    errorCount++;
                    continue;
                }

                try {
                    // Fetch track metadata from Spotify API
                    const data = await spotifyFetch("GET", "/tracks/" + parsed.id);
                    const fullDurationMs = data.duration_ms || 0;

                    if (!fullDurationMs) {
                        console.warn(`Track ${i + 1}: No duration_ms from API, skipping.`);
                        errorCount++;
                        continue;
                    }

                    const track = {
                        index: builderTracks.length + 1,
                        uri: parsed.uri,
                        trackId: parsed.id,
                        durationMs: fullDurationMs,
                        startMs: jsonTrack.startMs || 0,
                        clipMs: jsonTrack.durationMs || Math.min(2000, fullDurationMs),
                        meta: {
                            name: data.name || "Unknown title",
                            artists: (data.artists || []).map(a => a.name)
                        }
                    };

                    builderTracks.push(track);
                    successCount++;

                } catch (e) {
                    console.error(`Track ${i + 1}: Could not fetch metadata:`, e);
                    errorCount++;
                }
            }

            renderTracks();

            if (errorCount > 0) {
                showImportStatus(
                    `Imported ${successCount} track(s). ${errorCount} failed (see console for details).`,
                    true
                );
            } else {
                showImportStatus(`Successfully imported ${successCount} track(s).`, false);
            }
        }

        // =====================
        //   INIT
        // =====================

        window.addEventListener("DOMContentLoaded", async () => {
            const loginBtn = document.getElementById("loginBtn");
            if (loginBtn) {
                loginBtn.addEventListener("click", startAuth);
            }

            const openSpotifyBtn = document.getElementById("openSpotifyBtn");
            if (openSpotifyBtn) {
                openSpotifyBtn.addEventListener("click", () => {
                    window.open("https://open.spotify.com/", "_blank");
                });
            }

            // Playlist management
            document.getElementById("playlistSelect").addEventListener("change", loadSelectedPlaylist);
            document.getElementById("newPlaylistBtn").addEventListener("click", () => {
                const modal = new bootstrap.Modal(document.getElementById("newPlaylistModal"));
                modal.show();
            });
            document.getElementById("createPlaylistBtn").addEventListener("click", createNewPlaylist);

            // Track management
            document.getElementById("addTrackBtn").addEventListener("click", addTrackFromInput);
            document.getElementById("spotifyInput").addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    addTrackFromInput();
                }
            });

            // Import/Export
            document.getElementById("exportJsonBtn").addEventListener("click", exportJson);
            document.getElementById("importJsonBtn").addEventListener("click", importJson);

            // Save
            document.getElementById("saveToStorageBtn").addEventListener("click", saveToLocalStorage);

            await handleRedirectCallback();

            const stored = getStoredToken();
            if (stored && !accessToken) {
                accessToken = stored;
            }

            updateAuthStatus();
            checkDevices();
            populatePlaylistDropdown();
        });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
            crossorigin="anonymous"></script>
</body>
</html>